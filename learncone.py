# Bismillahi-r-Rahmani-r-Rahim

# Test of whether we can learn a cone using SVMs

import random

import numpy as np
import pylab as pl
from matplotlib.patches import Polygon
from sklearn.grid_search import GridSearchCV
from sklearn.metrics import fbeta_score, f1_score, precision_score, recall_score
from sklearn.base import BaseEstimator

import svmlight as svm

class SvmLightEstimator(BaseEstimator):
    def __init__(self, cost=None, cost_ratio=1.0, biased_hyperplane=False):
        self.svm = svm.Learner()
        if cost:
            self.svm.cost = cost
        self.svm.biased_hyperplane = biased_hyperplane
        self.svm.cost_ratio = cost_ratio

    def get_params(self, deep=True):
        return {'cost': self.svm.cost,
                'cost_ratio': self.svm.cost_ratio,
                'biased_hyperplane': self.svm.biased_hyperplane}
    
    def set_params(self, **params):
        if 'cost' in params:
            self.svm.cost = params['cost']
        if 'cost_ratio' in params:
            self.svm.cost_ratio = params['cost_ratio']
        if 'biased_hyperplane' in params:
            self.svm.biased_hyperplane = params['biased_hyperplane']
        return self

    def fit(self, data, class_values):
        self.model = self.svm.learn(data, class_values)
    
    def predict(self, data):
        return [1 if self.model.classify(d) > 0 else -1
                for d in data]

def get_cone_data():
    """
    Get points in the unit square and classifications assuming
    a cone generated by (1,3) and (1,1)
    """
    data = []
    for i in range(1000):
        x = np.random.uniform()
        y = np.random.uniform()
        in_cone = (y/x) >= 1./3 and (y/x) <= 1.
        #in_cone = (y/x) <= 0.7
        data += [(x,y,in_cone)]
    return data

def score(y_true, y_pred, labels=None, pos_label=1, average='weighted'):
    return fbeta_score(y_true, y_pred, 2, labels, pos_label, average)

    # z = zip(y_true, y_pred)
    # tp = len([x for x in z if x[0] == 1 and x[1] == 1])
    # tn = len([x for x in z if x[0] == -1 and x[1] == -1])
    # fp = len([x for x in z if x[0] == -1 and x[1] == 1])
    # tn = len([x for x in z if x[0] == 1 and x[1] == -1])
    # prec = float(tp)/(tp + fp)
    # rec = float(tp)/(tp + tn)
    # f1 = 2*(prec * rec)/(prec + rec)
    # return f1

def cross_validate(data, class_values):
    pars = {'cost': [1.0, 10.0, 100.0],
            'cost_ratio': [float(x)/4 for x in range(3, 10)]}
    search = GridSearchCV(SvmLightEstimator(), pars, score_func = score)
    search.fit(data, class_values)
    return search

def get_docs_and_class_values(data):
    docs = []
    for i in range(len(data)):
        docs.append(svm.Document(i, svm.SupportVector(
                    [(1, data[i][0]), (2, data[i][1])])))
    m = {True: 1, False: -1}
    class_values = [m[x[2]] for x in data]
    return docs, class_values

# def learn_plane(data, cost, cost_ratio):
#     "Find the best plane given the data"
#     docs, class_values = get_docs_and_class_values(data)
#     learner = svm.Learner()
#     learner.biased_hyperplane = False
#     learner.cost_ratio = cost_ratio
#     learner.cost = cost
#     # This doesn't seem to work...
#     #learner.remove_inconsistent = True
#     model = learner.learn(docs, class_values)
#     if model.bias != 0.0:
#         raise ValueError("Bias should be zero")
#     return model.plane

# def run():
#     data = get_cone_data()

#     for cost in [1.0, 10.0, 100.0, 1000.0]:
#         for cost_ratio in [1.0, 1.5, 2.0]:
#             plane = learn_plane(data, cost, cost_ratio)
#     print plane
#     plot(data, plane)

def plot(data, plane):
    pos = [x for x in data if x[2]]
    neg = [x for x in data if not x[2]]
    gradient = -plane[0]/plane[1]
    def plane_func(x):
        return gradient*x

    ax = pl.subplot(111)

    a, b = 0, 1 # integral area
    x = pl.arange(0, 1, 0.01)
    y = plane_func(x)
    pl.plot(x, y, linewidth=1)

    # make the shaded region
    ix = pl.arange(a, b, 0.01)
    iy = plane_func(ix)
    verts = [(a,0)] + list(zip(ix,iy)) + [(b,0)]
    poly = Polygon(verts, facecolor='0.8', edgecolor='k')
    ax.add_patch(poly)
    #pl.show()

    pl.plot([x[0] for x in pos], [x[1] for x in pos], 'ro')
    pl.plot([x[0] for x in neg], [x[1] for x in neg], 'bx')
    pl.show()

if __name__ == "__main__":
    data = get_cone_data()
    docs, class_values = get_docs_and_class_values(data)
    #print docs, class_values
    
    search = cross_validate(docs, class_values)

    for params, mean_score, scores in search.grid_scores_:
        print "%0.3f (+/-%0.03f) for %r" % (
            mean_score, scores.std() / 2, params)
   

    print search.best_score_, search.best_params_

    plane = search.best_estimator_.model.plane
    plot(data, plane)
